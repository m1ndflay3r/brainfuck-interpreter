#!/usr/bin/env zsh

## env setup

# input handling (program load)
bf_input="$1"

# error printout if program input is blank
blank_printout() {
  print -u2 "Error: no input provided, or input file empty"
  print -u2 "       syntax: bf_run ./input_file"
  print -u2 "               bf_run <input>"
}

# initial blank check
[ -z "$bf_input" ] && {
  blank_printout
  return 1
}

# if input is file, read from file and make new input
[ -f "$bf_input" ] && {
  bf_input=$(<"$bf_input")
}

# run blank check twice in case file is empty
[ -z "$bf_input" ] && {
  blank_printout
  return 1
}

# load zsh/mapfile for streamfile reading
zmodload zsh/mapfile

# streamfile defaults to /tmp/bf_streamfile if not user-defined
[ -z "$streamfile" ] && {
  streamfile=/tmp/bf_streamfile
}

# alias integer to int for brevity
alias int="integer"

# array declarations
declare -A tape # use associative array for tape as brainfuck expects 0-index
declare -a loop_stack

# variable declarations
int pointer killflag stream_offset abortflag

# set memory limit to 1048576 (1mb) if undefined
[ -z "$memlimit" ] && {
  int memlimit=1048576
# else, set memlimit to 1048576 X memlimit
} || {
  int memlimit=$((1048576*memlimit))
}

# since it's possible to set mem lower than 1mb via setting memlimit to 0<N<1, we add this check
((memlimit<1024)) && {
  print -u2 "Error: memlimit cannot be smaller than 1024 (1kb)"
  return 1
}

## helper functions

# output current cell contents
print_cell() {
  # use %02x to ensure 2 digit hex
  local target=${tape[$pointer]:-0}
  printf "\\x$(printf %02x $target)"
}

# decrease pointer by 1
pointer_decrement() {
  ((pointer==0)) && {
    # since this is emulated memory using arrays, we can semi-safely wrap without risking memory of other processes
    # typically, you should not do this, especially if your bf interpreter is written in a low-level lang
    print -u2 "WARN: mem limit exceeded!"
    print -u2 "There be monsters beyond this point."
    print -n -u2 "Continue anyway? (N/y) "
    # explicitly read from /dev/tty to avoid eating program input
    read -k1 do_cont < /dev/tty
    print -u2 # print newline after read for clean UI
    [[ "$do_cont" = [yY] ]] && {
      ((pointer=memlimit))
    } || {
      print -u2 "Segmentation Fault"
      ((abortflag++))
    }
  } || {
    ((pointer--))
  }
}

# increase pointer by 1
pointer_increment() {
  ((pointer==memlimit)) && {
    # since this is emulated mem using arrays, we can semi-safely wrap without risking the memory of other processes
    # typically, you should not do this, especially if your bf interpreter is written in a low-level lang
    print -u2 "WARN: mem limit exceeded!"
    print -u2 "There be monsters beyond this point."
    print -n -u2 "Continue anyway? (N/y) "
    read -k1 do_cont < /dev/tty
    print -u2 # newline after read for clean U.I
    [[ "$do_cont" = [yY] ]] && {
      ((pointer=0))
    } || {
      print -u2 "Segmentation Fault"
      ((abortflag++))
    }
  } || {
    ((pointer++))
  }
}

# increment current cell
cell_increment() {
  # we use bitmask to keep values within 255, and uninitialized cells are treated as zero
  tape[$pointer]=$(((${tape[$pointer]:-0}+1)&255))
}

# decrement current cell
cell_decrement() {
  # we use bitmask to keep values within 255, and uninitialized cells are treated as zero
  tape[$pointer]=$(((${tape[$pointer]:-0}-1)&255))
}

# read byte from input stream
stream_read() {
  # while a bit inefficient, this method allows mid-program streamfile modification
  # and is more than fast enough for our purposes
  [[ -f "$streamfile" ]] && {
    sr_working=${mapfile[$streamfile]:$stream_offset:1}
    ((stream_offset++))
    # if sr_working empty, treat as zero
    [ -z "$sr_working" ] && {
      tape[$pointer]=0
    } || {
      # conv sr_working to ascii, store in current cell
      tape[$pointer]=$(printf "%d" "'$sr_working")
    }
  # if file not exist, treat as zero
  } || {
    tape[$pointer]=0
    ((stream_offset++))
  }
}

r_jmp() {
  ((${tape[$pointer]:-0} == 0)) && {
  ## jump if zero
    # depth flag keeps track of nested loops
    int depth=1
    # loop repeats while depth >= 1
    while ((depth > 0)); do
      # if bf_input empty, we've reached end of program without discovering [
      # which according to brainfuck spec we must treat as a fatal error
      [ -z "$bf_input" ] && {
        print -u2 "FATAL: Unbalanced \'[\' (encountered r_jmp, but found no closing bracket)"
        ((abortflag++))
      }
      # pop next char off stack
      local next_char=${bf_input::1}
      bf_input=${bf_input:1}
      # if next char is '[', we've encountered a nested loop and must increase depth counter
      [[ "$next_char" = "[" ]] && {
        ((depth++))
      }
      # if next char is ']', we've encountered closing brace and must decrease depth counter
      [[ "$next_char" = "]" ]] && {
        ((depth--))
      }
    done
  } || {
  ## else push stack
    loop_stack+=("$bf_input")
  }
}

l_jmp() {
  ((${tape[$pointer]:-0} != 0)) && {
  ## jump if not zero
    # if loop stack empty, we haven't encountered '[' yet.
    # according to brainfuck spec, we treat this as a fatal error
    ((${#loop_stack} == 0)) && {
      print -u2 "FATAL: Unbalanced \']\' (encountered l_jmp, but found no closing bracket)"
      ((abortflag++))
    }
    # restore stack (revert to point of matching '[', thus completing l_jmp)
    bf_input="${loop_stack[-1]}"
  } || {
  ## else pop stack
    loop_stack[-1]=()
  }
}

## main

while true; do
  # if bf_input is empty and program not killed, return 0 (success)
  [ -z "$bf_input" ] && return 0
  # pop one char off input
  bf_working=${bf_input::1}
  bf_input=${bf_input:1}
  # instruction interpretation
  case $bf_working in
    ('<') pointer_decrement ;;
    ('>') pointer_increment ;;
    ('+') cell_increment ;;
    ('-') cell_decrement ;;
    ('.') print_cell ;;
    (',') stream_read ;;
    ('[') r_jmp ;;
    (']') l_jmp ;;
  esac
  ((abortflag>=1)) && return 1
done
