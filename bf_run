#!/usr/bin/env zsh

## env setup

# input handling (program load)
bf_input="$1"

# error printout if program input is blank
blank_printout() {
  print "Error: no input provided, or input file empty"
  print "       syntax: bf_run ./input_file"
  print "               bf_run $input"
}

# initial blank check
[ -z "$bf_input" ] && {
  blank_printout
  return 1
}

# if input is file, read from file and make new input
[ -f "$bf_input" ] && {
  bf_input=$(<"$bf_input")
}

# run blank check twice in case file is empty
[ -z "$bf_input" ] && {
  blank_printout
  return 1
}

# streamfile defaults to /tmp/bf_streamfile if not user-defined
[ -z "$streamfile" ] && {
  streamfile=/tmp/bf_streamfile
}

# load zselect for micro-sleep
zmodload zsh/zselect

# alias integer to int for brevity
alias int="integer"

# array declarations
declare -A tape # use associative array for tape as bf expects 0-index

# variable declarations
int pointer killflag stream_offset=1 abortflag

# set memory limit to 1048576 (1mb) if undefined
[ -z "$memlimit" ] && {
  int memlimit=1048576
# else, set memlimit to 1048576 X memlimit
} || {
  int memlimit=$((1048576*memlimit))
}

# since it's possible to set mem lower than 1mb via setting memlimit to 0<N<1, we add this check
((memlimit<1024)) && {
  print "Error: memlimit cannot be smaller than 1024 (1kb)"
  return 1
}

# valid instruction table
bf_instructions=('>'
                 '<'
                 '+'
                 '-'
                 '.'
                 ','
                )

## helper functions

# output current cell contents
print_cell() {
  # convert from binary to hex
  local target=$(([##16]2#$tape[$pointer]))
  # since highest register value is FF (255) we can
  # just treat as a single byte rather than loop
  # and output corresponding byte with \x
  print -n "\x"$target""
}

# decrease pointer by 1
pointer_decrement() {
  ((pointer==0)) && {
    # since we're emulating memory with an array, we can wrap semi-safely without risking external memory
    # typically, you should not do this, especially if your bf interpreter is written in a low-level lang
    print "WARN: mem limit exceeded!"
    print "There be monsters beyond this point."
    responses=('y' 'Y' 'yes' 'Yes' 'YES' )
    print -n "Continue anyway? (N/y) "
    read do_cont
    contflag=0
    for resp in $responses[@]; do
      [[ "$resp" = "$do_cont" ]] && {
        contflag=1
        break
      }
    done
    (("$contflag"==0)) && {
      ((abortflag++))
    }
    ((pointer=memlimit))
  } || {
    ((pointer--))
  }
}

# increase pointer by 1
pointer_increment() {
  ((pointer==memlimit)) && {
    # since we're emulating memory with an array, we can wrap semi-safely without risking external memory
    # typically, you should not do this, especially if your bf interpreter is written in a low-level lang
    print "WARN: mem limit exceeded!"
    print "There be monsters beyond this point."
    responses=('y' 'Y' 'yes' 'Yes' 'YES' )
    print -n "Continue anyway? (N/y) "
    read do_cont
    contflag=0
    for resp in $responses[@]; do
      [[ "$resp" = "$do_cont" ]] && {
        contflag=1
        break
      }
    done
    (("$contflag"==0)) && {
      ((abortflag++))
    }
    ((pointer=0))
  } || {
    ((pointer++))
  }
}

# increment current cell
cell_increment() {
  # fetch current val
  current_val=$tape[$pointer]
  # set to 00000000 if is 11111111 (255)
  current_val=$((2#$current_val))
  ((current_val>=255)) && {
    tape[$pointer]=00000000
  # else increment + store
  } || {
    ((current_val++))
    tape[$pointer]=$(([##2]$current_val))
  }
}

# decrement current cell
cell_decrement() {
  current_val=$tape[$pointer]
  # set to 11111111 (255) if is 0
  current_val=$((2#$current_val))
  ((current_val==0)) && {
    tape[$pointer]=11111111
  # else decrement + store
  } || {
    ((current_val--))
    tape[$pointer]=$(([##2]$current_val))
  }
}

# read byte from input stream, replace value of current cell with read byte
stream_read() {
  # while this method is a bit inefficient, it allows
  # us to externally modify streamfile mid-program
  # and is more than fast enough for this use-case
  local sr_working=$(([##2]$((0x$(printf "%02x" "'${"${"$(<$streamfile)"::$stream_offset}":$((stream_offset-1))}")))))
  ((stream_offset++))
  # normalize to 8 bits (0 pad)
  ((${#sr_working}<8)) && {
    until ((${#sr_working}==8)); do
      sr_working="0"$sr_working""
    done
  }
  # write to tape
  tape[$pointer]="$sr_working"
}

## main

# while true mimics clock cycle
while true; do
  # read next instruction from input
  # we use a loop for this since brainfuck ignores chars
  # which aren't instructions
  int breakflag=0
  while true; do
    # pop one char off input
    bf_working=${bf_input::1}
    bf_input=${bf_input:1}
    # if working is empty, we've reached end of program
    [ -z "$bf_working" ] && {
      ((breakflag++))
      ((killflag++))
      break
    }
    ## we handle jump here
    # treat uninitialized cell as 0
    [ -z "$tape[$pointer]" ] && {
      tape[$pointer]='0'
    }
    # if current instruction is ]
    # (jump if not zero, aka L JMP)
    [[ "$bf_working" = ']' ]] && {
      mostrecent_ljmp="$bf_input"
      # if pointer is not zero, jump
      [[ "$tape[$pointer]" != 0 ]] && {
        # if mostrecent_rjmp is empty, assume we
        # havent encountered [ yet and abort
        [ -z "$mostrecent_rjmp" ] && {
          print "FATAL: encountered l_jmp but have not encountered closing bracket yet"
          ((abortflag++))
        }
        bf_working=${mostrecent_rjmp: :1}
        bf_input=${mostrecent_rjmp:1}
      }
    # else, if current working instruction is [
    # (jump if zero, aka R JMP)
    } || {
      [[ "$bf_working" = '[' ]] && {
        mostrecent_rjmp="$bf_input"
        # if pointer is zero, jump
        [[ "$tape[$pointer]" = 0 ]] && {
          # begin iteration until we find closing bracket
          while true; do
            bf_working=${bf_input::1}
            bf_input=${bf_input:1}
            # if working is empty, we've reached end of program without finding closing brace.
            # this is, naturally, a fatal error
            [ -z "$bf_working" ] && {
              print "FATAL: encountered r_jmp but found no closing bracket"
              ((abortflag++))
              break
            }
            # if bf_working is closing brace, we've found our mark.
            # bf_input becomes new most recent l_jmp, and we break loop
            [[ "$bf_working" = ']' ]] && {
              mostrecent_ljmp="$bf_input"
              break
            }
          done
        }
      }
    }
    # check if valid instruction
    for inst in $=bf_instructions; do
      [ "$bf_working" = "$inst" ] && {
        ((breakflag++))
        break
      }
    done
    # if instruction valid, breakflag should now be non-zero
    # so we end instruction fetch loop
    ((breakflag!=0)) && {
      break
    }
  done
  # if killflag isnt 0, we've reached end of program
  ((killflag!=0)) && {
    break
  }
  # instruction interpretation
  case $bf_working in
    ('<') pointer_decrement ;;
    ('>') pointer_increment ;;
    ('+') cell_increment ;;
    ('-') cell_decrement ;;
    ('.') print_cell ;;
    (',') stream_read ;;
  esac
  ((abortflag==1)) && {
    return 1
  }
done
